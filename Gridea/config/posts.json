{
  "posts": [
    {
      "content": "\r\n# 题目\r\n\r\n给定一个仅包含大小写字母和空格 ' ' 的字符串 s，返回其最后一个单词的长度。\r\n如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。\r\n如果不存在最后一个单词，请返回 0 。\r\n说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。\r\n\r\n示例:\r\n输入: \"Hello World\"\r\n输出: 5\r\n\r\n\r\n\r\n\"\"\"\"\"\"\r\n\r\n# 本体思路\r\n\r\n\r\n我工作效率低的原因完全是因为有和力扣的题干一样语文为负分的产品经理\r\n由于有这种情况发生输入:\"a \"，输出:1\r\n我们先要把左右测的空格去掉。然后利用rfind函数找到最后一个\"\"在哪就行了。\r\n\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution:\r\n    def lengthOfLastWord(self, s: str) -> int:\r\n        s=s.strip(\" \")\r\n        if \" \" in s:\r\n            if set(s)!={\" \"}:\r\n                inde=s.rfind(\" \")\r\n                return len(s)-inde-1\r\n            else:\r\n                return 0\r\n        else:\r\n            return len(s)\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "58、最后一个单词的长度",
        "date": "2020-11-11 20:41:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/53、最大子序列.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "58、最后一个单词的长度"
    },
    {
      "content": "       今天学到了分治和动态规划的初步过程，非常的开心，一定要记得多bug。\r\n有些思想其实不难，要多思考就行。\r\n    （退了一个枕头，只亏了3元运费，挺好的）😏",
      "data": {
        "title": "今天学到了分治和动态规划的初步过程",
        "date": "2020-11-10 18:47:33",
        "tags": [
          "生活日常"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/jin-tian-xue-dao-liao-fen-zhi-he-dong-tai-gui-hua-de-chu-bu-guo-cheng.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "jin-tian-xue-dao-liao-fen-zhi-he-dong-tai-gui-hua-de-chu-bu-guo-cheng"
    },
    {
      "content": "\r\n# 题目\r\n\r\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\r\n\r\n示例:\r\n输入: [-2,1,-3,4,-1,2,1,-5,4]\r\n输出: 6\r\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\r\n\r\n\r\n\r\n\r\n\r\n\"\"\"\"\"\"\r\n\r\n# 本体思路\r\n\r\n\r\n\r\n思路分析：\r\n\r\n这就是动态规划吗！爱了爱了！\r\n先一步一步进行，为后一次做好准备。\r\n基本思路就是遍历一遍，用两个变量，一个记录最大的和，一个记录当前的和。时空复杂度貌似还不错......\r\n如图所示\r\n![](https://ganhan999.github.io//post-images/1605005219420.jpg)\r\n![](https://ganhan999.github.io//post-images/1605005223397.jpg)\r\n![](https://ganhan999.github.io//post-images/1605005226966.jpg)\r\n![](https://ganhan999.github.io//post-images/1605005233354.jpg)\r\n![](https://ganhan999.github.io//post-images/1605005236246.jpg)\r\n![](https://ganhan999.github.io//post-images/1605005238680.jpg)\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution:\r\n    def maxSubArray(self, nums: List[int]) -> int:\r\n        sum=nums[0]\r\n        ans=nums[0]#一开始就要给nums[0]，不然如果第一个数是负数就惨了\r\n        for i in range(len(nums)-1):\r\n            num=nums[i+1]\r\n            if sum<=0:\r\n                sum=num#小于零，就把前面的都不算\r\n                ans=max(sum,ans)#看是之前大还是现在大\r\n            else:\r\n                sum=sum+num\r\n                ans=max(sum,ans)#看是之前大还是现在大\r\n        return ans\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\"\"\"\"\"\"\r\n\r\n# 大神做法1：\r\n\r\n最简单的的动态规划！这才是最简单的！\r\n\r\n```python\r\nclass Solution:\r\n    def maxSubArray(self, nums: List[int]) -> int:\r\n        for i in range(1,len(nums)):\r\n            nums[i] = max(nums[i-1]+nums[i],nums[i])#如果我前面加起来的值是一个正数，那么就继续加。\r\n                                                    # 如果不是的话，抱歉我要从头开始了。\r\n        return max(nums)\r\n\r\n\r\n#复现成功！\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\"\"\"\"\"\r\n\r\n# 大神做法2：\r\n\r\n分治思想\r\n\r\n```python\r\nclass Solution:\r\n    def maxSubArray(self, nums: List[int]) -> int:\r\n        n = len(nums)\r\n        # 递归终止条件\r\n        if n == 1:\r\n            return nums[0]\r\n        else:\r\n            # 递归计算左半边最大子序和\r\n            max_left = self.maxSubArray(nums[0:len(nums) // 2])\r\n            # 递归计算右半边最大子序和\r\n            max_right = self.maxSubArray(nums[len(nums) // 2:len(nums)])\r\n        # 计算中间的最大子序和，从右到左计算左边的最大子序和，从左到右计算右边的最大子序和，再相加\r\n        # 以下条件是只有n>1才会发生的\r\n        #拆分为二叉树的形式，递归求出每一个子树的最大值。\r\n        a=nums\r\n        max_l = nums[len(nums) // 2 - 1]\r\n        tmp = 0\r\n        for i in range(len(nums) // 2 - 1, -1, -1):\r\n            tmp += nums[i]\r\n            max_l = max(tmp, max_l)\r\n        max_r = nums[len(nums) // 2]\r\n        tmp = 0\r\n        for i in range(len(nums) // 2, len(nums)):\r\n            tmp += nums[i]\r\n            max_r = max(tmp, max_r)\r\n        # 返回三个中的最大值\r\n        return max(max_right, max_left, max_l + max_r)\r\n #复现成功\r\n```\r\n\r\n\r\n",
      "data": {
        "title": "53、最大子序列",
        "date": "2020-11-10 18:41:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/53、最大子序列.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "53、最大子序列"
    },
    {
      "content": "\r\n# 题目\r\n\r\n给定一个正整数 n ，输出外观数列的第 n 项。\r\n「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。\r\n你可以将其视作是由递归公式定义的数字字符串序列：countAndSay(1) = \"1\"\r\ncountAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。\r\n前五项如下：\r\n\r\n1.     1\r\n2.     11\r\n3.     21\r\n4.     1211\r\n5.     111221\r\n第一项是数字 1\r\n描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 \"11\"\r\n描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 \"21\"\r\n描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 \"1211\"\r\n描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 \"111221\"\r\n要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多\r\n相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。\r\n要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。\r\n\r\n示例 1：\r\n输入：n = 1\r\n输出：\"1\"\r\n解释：这是一个基本样例。\r\n\r\n示例 2：\r\n输入：n = 4\r\n输出：\"1211\"\r\n解释：\r\ncountAndSay(1) = \"1\"\r\ncountAndSay(2) = 读 \"1\" = 一 个 1 = \"11\"\r\ncountAndSay(3) = 读 \"11\" = 二 个 1 = \"21\"\r\ncountAndSay(4) = 读 \"21\" = 一 个 2 + 一 个 1 = \"12\" + \"11\" = \"1211\"\r\n\r\n\r\n\r\n\r\n\r\n\"\"\"\"\"\"\r\n\r\n# 本体思路\r\n\r\n\r\n\r\n利用递归的思想，如果当后一个元素不等于前一个元素停止计数，以此类推。主要是递归的思想要掌握！\r\n\r\n\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        if target in nums:\r\n            return nums.index(target)\r\n        else:\r\n            nums.append(target)\r\n            nums.sort(reverse=False)\r\n            return nums.index(target)\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\"\"\"\"\"\"\r\n\r\n# 大神做法1：\r\n\r\n双指针探测\r\n\r\n如图所示\r\n![](https://ganhan999.github.io//post-images/1604929111425.gif)\r\n```python\r\nclass Solution:\r\n    def countAndSay(self, n: int) -> str:\r\n        pre = ''\r\n        cur = '1'#默认为“1”\r\n        # 从第 2 项开始\r\n        for _ in range(1, n):\r\n            # 这里注意要将 cur 赋值给 pre\r\n            # 因为当前项，就是下一项的前一项。有点绕，尝试理解下\r\n            pre = cur\r\n            # 这里 cur 初始化为空，重新拼接\r\n            cur = ''\r\n            # 定义双指针 start，end\r\n            start = 0\r\n            end = 0\r\n            # 开始遍历前一项，开始描述\r\n            while end < len(pre):\r\n                # 统计重复元素的次数，出现不同元素时，停止\r\n                # 记录出现的次数，\r\n                while end < len(pre) and pre[start] == pre[end]:\r\n                    end += 1\r\n                # 元素出现次数与元素进行拼接\r\n                cur += str(end - start) + pre[start]\r\n                # 这里更新 start，开始记录下一个元素\r\n                start = end\r\n        return cur\r\n\r\n\r\n#复现成功！\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\"\"\"\"\"\r\n\r\n# 大神做法2：\r\n\r\n递归和迭代简单算法\r\n\r\n```python\r\n#递归\r\ndef countAndSay(self, n: int) -> str:\r\n    if n == 1:\r\n        return '1'\r\n    s = self.countAndSay(n - 1)\r\n\r\n    i, res = 0, ''\r\n    for j, c in enumerate(s):\r\n        if c != s[i]:\r\n            res += str(j - i) + s[i]#后面使用 j - i 来统计相同元素的个数，这样最后会剩下最后一堆相同的数字。\r\n            i = j\r\n    res += str(len(s) - i) + s[-1]  # 所以最后一个元素莫忘统计\r\n    return res\r\n\r\n#迭代\r\ndef countAndSay(self, n: int) -> str:\r\n    res = '1'#默认为“1”\r\n    for _ in range(n-1):  # 控制循环次数\r\n        i, tmp = 0, ''\r\n        for j, c in enumerate(res):\r\n            if c != res[i]:\r\n                tmp += str(j-i) + res[i]\r\n                i = j\r\n        res = tmp + str(len(res) - i) + res[-1]\r\n    return res\r\n\r\n#复现成功！\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\"\"\"\"\"\"\r\nPython递归的要点\r\n1、一定要画图\r\n2、在最前面写上递归停止的条件\r\n3、在递归函数后面要写上你相对应的操作，并在最后写上return\r\n\r\nPython迭代的要点\r\n1、利用while循环将递归变为非递归\r\n\r\n\r\n\r\n递归和迭代的区别：\r\n\r\n斐波那契数列的实现\r\n\r\n```\r\n【递归实现】\r\n\r\ndef fib(x):\r\n    if x <2:\r\n        return 0 if x==0 else 1\r\n    else:\r\n        return fib(x - 1) + fib(x - 2)\r\nprint(fib(6))\r\n```\r\n\r\n\r\n\r\n\r\n【迭代实现】\r\n\r\n```\r\ndef fib(x):\r\n    n1 = 1\r\n    n2 = 1\r\n    n3 = 1\r\n    while x-2 > 0:\r\n       n3 = n2 + n1\r\n       n1 = n2\r\n       n2 = n3\r\n       x -= 1\r\n   return n3\r\n\r\nnum = int(input('请输入一个正整数：'))\r\nprint(fib(num))\r\n```\r\n\r\n",
      "data": {
        "title": "38、外观数列",
        "date": "2020-11-09 21:31:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/38、外观数列.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "38、外观数列"
    },
    {
      "content": "\r\n\r\n描述\r\nmap() 会根据提供的函数对指定序列做映射。\r\n\r\n第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。\r\n\r\n语法\r\nmap() 函数语法：\r\n\r\nmap(function, iterable, ...)\r\n参数\r\nfunction -- 函数\r\niterable -- 一个或多个序列\r\n返回值\r\nPython 2.x 返回列表。\r\n\r\nPython 3.x 返回迭代器。\r\n\r\n实例\r\n以下实例展示了 map() 的使用方法：\r\n![](https://ganhan999.github.io//post-images/1604890237344.jpg)\r\n>>>def square(x) :            # 计算平方数\r\n...     return x ** 2\r\n... \r\n>>> map(square, [1,2,3,4,5])   # 计算列表各个元素的平方\r\n[1, 4, 9, 16, 25]\r\n>>> map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 使用 lambda 匿名函数\r\n[1, 4, 9, 16, 25]\r\n \r\n# 提供了两个列表，对相同位置的列表数据进行相加\r\n>>> map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])\r\n[3, 7, 11, 15, 19]",
      "data": {
        "title": "Python map() 函数",
        "date": "2020-11-09 10:50:16",
        "tags": [
          "生活日常"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/python-map-han-shu.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-map-han-shu"
    },
    {
      "content": "\r\n\r\n# 题目\r\n\r\n\"\"\"\r\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。\r\n如果目标值不存在于数组中，返回它将会被按顺序插入的位置\r\n\r\n你可以假设数组中无重复元素。\r\n示例 1:\r\n输入: [1,3,5,6], 5\r\n输出: 2\r\n\r\n示例 2:\r\n输入: [1,3,5,6], 2\r\n输出: 1\r\n\r\n示例 3:\r\n输入: [1,3,5,6], 7\r\n输出: 4\r\n\r\n示例 4:\r\n输入: [1,3,5,6], 0\r\n输出: 0\r\n\r\n\"\"\"\r\n\r\n# 本体思路\r\n\r\n\r\n\r\n利用python中index函数便可以直接找到，子字符串的初始位置。\r\n\r\n\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        if target in nums:\r\n            return nums.index(target)\r\n        else:\r\n            nums.append(target)\r\n            nums.sort(reverse=False)\r\n            return nums.index(target)\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n# 大神做法1：\r\n\r\n因为有序，所以只需要比较比它小的数的最大值\r\n\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        return len([i for i in nums if i < target])\r\n\r\n\r\n#复现成功！\r\n```\r\n\r\n\r\n\r\n# 大神做法2：\r\n\r\n利用切片思想，循环len(haystack) - len(needle) + 1次\r\n\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        low=0\r\n        high=len(nums)\r\n        while(low<high):\r\n            mid=low+(high-low)//2# “ / ” 为浮点数除法，返回浮点结果\r\n                                 # “ // ” 表示整数除法，返回不大于结果的一个最大整数\r\n            if nums[mid] > target:\r\n                high=mid\r\n            elif nums[mid]<target:\r\n                low=mid+1\r\n            else:\r\n                return mid\r\n        return low\r\n\r\n#复现成功！\r\n```\r\n\r\n\"\"\"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\"\"\"\r\n\r\nPython如何对列表排序？\r\nPython list内置sort()方法用来排序，也可以用python内置的全局sorted()方法来对可迭代的序列排序生成新的序列。\r\n\r\n1）排序基础\r\n\r\n简单的升序排序是非常容易的。只需要调用sorted()方法。它返回一个新的list，新的list的元素基于小于运算符(__lt__)来排序。\r\n\r\n>>> sorted([5, 2, 3, 1, 4])\r\n[1, 2, 3, 4, 5]\r\n你也可以使用list.sort()方法来排序，此时list本身将被修改。通常此方法不如sorted()方便，但是如果你不需要保留原来的list，此方法将更有效。\r\n\r\n>>> a = [5, 2, 3, 1, 4]\r\n>>> a.sort()\r\n>>> a\r\n[1, 2, 3, 4, 5]\r\n另一个不同就是list.sort()方法仅被定义在list中，相反地sorted()方法对所有的可迭代序列都有效。\r\n\r\n>>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})\r\n[1, 2, 3, 4, 5]\r\n\r\n2）key参数/函数\r\n\r\n从python2.4开始，list.sort()和sorted()函数增加了key参数来指定一个函数，此函数将在每个元素比较前被调用。 例如通过key指定的函数来忽略字符串的大小写：\r\n\r\n>>> sorted(\"This is a test string from Andrew\".split(), key=str.lower)\r\n['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']\r\nkey参数的值为一个函数，此函数只有一个参数且返回一个值用来进行比较。这个技术是快速的因为key指定的函数将准确地对每个元素调用。\r\n\r\n更广泛的使用情况是用复杂对象的某些值来对复杂对象的序列排序，例如：\r\n\r\n复制代码\r\n>>> student_tuples = [\r\n        ('john', 'A', 15),\r\n        ('jane', 'B', 12),\r\n        ('dave', 'B', 10),\r\n]\r\n>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age\r\n[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\r\n\r\n\"\"\"\r\n\r\nPython如何在列表中增加元素？\r\n\r\n1. append() 追加单个元素到List的尾部，只接受一个参数，参数可以是任何数据类型，被追加的元素在List中保持着原结构类型。\r\n\r\n此元素如果是一个list，那么这个list将作为一个整体进行追加，注意append()和extend()的区别。\r\n\r\n复制代码代码如下:\r\n\r\n>>> list1=['a','b']\r\n>>> list1.append('c')\r\n>>> list1\r\n['a', 'b', 'c']\r\n\r\n\r\n2. extend() 将一个列表中每个元素分别添加到另一个列表中，只接受一个参数；extend()相当于是将list B 连接到list A上。\r\n\r\n复制代码代码如下:\r\n\r\n>>> list1\r\n['a', 'b', 'c']\r\n>>> list1.extend('d')\r\n>>> list1\r\n['a', 'b', 'c', 'd']\r\n\r\n\r\n3. insert() 将一个元素插入到列表中，但其参数有两个（如insert(1,”g”)），第一个参数是索引点，即插入的位置，第二个参数是插入的元素。\r\n\r\n复制代码代码如下:\r\n\r\n>>> list1\r\n['a', 'b', 'c', 'd']\r\n>>> list1.insert(1,'x')\r\n>>> list1\r\n['a', 'x', 'b', 'c', 'd']\r\n\r\n4. +加号，将两个list相加，会返回到一个新的list对象，注意与前三种的区别。前面三种方法（append, extend, insert）可对列表增加元素的操作，他们没有返回值，是直接修改了原数据对象。 注意：将两个list相加，需要创建新的list对象，从而需要消耗额外的内存，特别是当list较大时，尽量不要使用“+”来添加list，而应该尽可能使用List的append()方法。\r\n\r\n复制代码代码如下:\r\n\r\n>>> list1\r\n['a', 'x', 'b', 'c', 'd']\r\n>>> list2=['y','z']\r\n>>> list3=list1+list2\r\n>>> list3\r\n['a', 'x', 'b', 'c', 'd', 'y', 'z']\r\n\r\n\r\n\"\"\"",
      "data": {
        "title": "35、搜索插入位置",
        "date": "2020-11-08 19:54:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/35、搜索插入位置.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "35、搜索插入位置"
    },
    {
      "content": "体测起来之后直接废人一个 跪了TAT\r\n今天Python算法书终于到了 舒服的很\r\nopencv库真有点意思 老师讲的也不错 \r\n之后就是算法\r\n然后就是狂神 yyds了！\r\n",
      "data": {
        "title": "11.8杂记",
        "date": "2020-11-08 19:52:54",
        "tags": [
          "生活日常"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/11.8杂记.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "11.8杂记"
    },
    {
      "content": "\r\n今天又迎来了一年一度的体测，这也是我在大学生涯中最后一次体测，居然1000米又摸鱼了一回。\r\n本来以为不累的，午睡睡一觉还是起不来哈哈哈哈（淦）\r\n\r\n今天就要开始学习opencv了，争取早点看完 然后再学python和算法。\r\n\r\n之后就是我的开发大法好了！\r\n\r\n兄弟们冲！\r\n😋",
      "data": {
        "title": "体测结束了",
        "date": "2020-11-07 18:16:56",
        "tags": [
          "生活日常"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/ti-ce-jie-shu-liao.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ti-ce-jie-shu-liao"
    },
    {
      "content": "\r\n\r\n# 题目\r\n\r\n\"\"\"\r\n实现 strStr() 函数。\r\n\r\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出\r\nneedle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。\r\n\r\n示例 1:\r\n输入: haystack = \"hello\", needle = \"ll\"\r\n输出: 2\r\n\r\n示例 2:\r\n输入: haystack = \"aaaaa\", needle = \"bba\"\r\n输出: -1\r\n\r\n说明:\r\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\r\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\r\n\r\n\"\"\"\r\n\r\n# 本体思路\r\n\r\n\r\n\r\n利用python中find函数便可以直接找到，子字符串的初始位置。\r\n\r\n\r\n\r\n\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution:\r\n    def removeElement(self, nums: List[int], val: int) -> int:\r\n        lens=len(nums)\r\n        i=0\r\n        if lens==0:\r\n            return 0\r\n        while i<=lens-1:\r\n            if val in nums:\r\n                inde=nums.index(val)\r\n                nums.pop(inde)\r\n                print()\r\n            else:\r\n                i=i+1\r\n        return len(nums)\r\n\r\n```\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n# 大神做法1：\r\n\r\n双指针法：题意可以理解为直接修改前k个数，因此无需删除操作\r\n\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def strStr(self, haystack: str, needle: str) -> int:\r\n        if not needle:\r\n            return 0\r\n        return haystack.find(needle)\r\n\r\n\r\n\r\n#复现成功！\r\n```\r\n\r\n\r\n\r\n# 大神做法2：\r\n\r\n利用切片思想，循环len(haystack) - len(needle) + 1次\r\n\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def strStr(self, haystack: 'str', needle: 'str') -> 'int':\r\n        for i in range(0, len(haystack) - len(needle) + 1):\r\n            if haystack[i:i + len(needle)] == needle:\r\n                return i\r\n        return -1\r\n\r\n\r\n#复现成功！\r\n```\r\n\r\n\"\"\"\r\n\r\n\r\n\r\n\"\"\"\r\n下面是find函数的介绍\r\n\r\n\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n\r\n",
      "data": {
        "title": "28、实现 strStr()",
        "date": "2020-11-07 18:04:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/28、 实现 strStr().jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "28、 实现 strStr()"
    },
    {
      "content": "\r\n\r\n# 题目\r\n\r\n\"\"\"\r\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\r\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\r\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\r\n\r\n示例 1:\r\n给定 nums = [3,2,2,3], val = 3,\r\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\r\n你不需要考虑数组中超出新长度后面的元素。\r\n\r\n示例 2:\r\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\r\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\r\n注意这五个元素可为任意顺序。\r\n你不需要考虑数组中超出新长度后面的元素。\r\n\r\n\"\"\"\r\n\r\n# 本体思路\r\n\r\n\r\n\r\n如果val在列表中，那么就使用index函数得到他的位置，然后再进行一个一个的pop，比较简单\r\n\r\n\r\n\r\n\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution:\r\n    def removeElement(self, nums: List[int], val: int) -> int:\r\n        lens=len(nums)\r\n        i=0\r\n        if lens==0:\r\n            return 0\r\n        while i<=lens-1:\r\n            if val in nums:\r\n                inde=nums.index(val)\r\n                nums.pop(inde)\r\n                print()\r\n            else:\r\n                i=i+1\r\n        return len(nums)\r\n\r\n```\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n# 大神做法1：\r\n\r\n双指针法：题意可以理解为直接修改前k个数，因此无需删除操作\r\n\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def removeElement(self, nums: List[int], val: int) -> int:\r\n        for i in range(nums.count(val)):\r\n            nums.remove(val)\r\n        return len(nums)\r\n\r\n\r\n\r\n#复现成功！\r\n```\r\n\r\n\r\n\r\n# 大神做法2：\r\n\r\n双指针其实就是两个数，分别代表两个index，表示数组中第几个数的意思。\r\n比如这里，我们让a代表一个index，b代表一个index\r\n然后我们让a一直往后移动，相当于nums[a]从数组第一个数遍历到最后一个数。\r\n当且仅当我们发现nums[a] != val的时候，我们把这个数拷贝到b指向的位置，\r\n默认b是从0开始的，然后b += 1指向下一个位置。\r\n\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def removeElement(self, nums: List[int], val: int) -> int:\r\n        a = 0\r\n        b = 0\r\n\r\n        while a < len(nums):\r\n            if nums[a] != val:\r\n                nums[b] = nums[a]\r\n                b += 1\r\n            a += 1\r\n        return b\r\n\r\n\r\n#复现成功！\r\n```\r\n\r\n\"\"\"\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "27、移除元素",
        "date": "2020-11-06 21:04:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/27、移除元素.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "27、移除元素"
    },
    {
      "content": "\r\n\r\n# 边缘检测\r\n\r\n\r\n边缘检测是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。图像属性中的显著变化通常反映了属性的重要事件和变化。这些包括：深度上的不连续、表面方向不连续、物质属性变化和场景照明变化。 \r\n\r\n\r\n\r\n\r\n\r\n# 检测思路\r\n\r\n\r\n\r\n图像的边缘有方向和幅度两种属性。边缘通常可以通过**一阶导数**或**二阶导数**检测得到。**一阶导数**是以**最大值**作为对应的边缘的位置，而**二阶导数**则以**过零点**作为对应边缘的位置。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Roberts 算子\r\n\r\n**Roberts算子**又称为交叉微分算法，它是基于交叉差分的梯度算法，通过局部差分计算检测边缘线条。常用来处理具有陡峭的低噪声图像，当图像边缘接近于正45度或负45度时，该算法处理效果更理想。其缺点是对边缘的定位不太准确，提取的边缘线条较粗。\r\n\r\n\r\n\r\n下面给出**Roberts算子**的**模板**，在**像素点P5处** x 和 y 方向上的梯度大小gx和gy\r\n\r\n![img](https://img-blog.csdnimg.cn/20190505104614320.png)\r\n![](https://ganhan999.github.io//post-images/1604651076241.png)\r\nopencv代码为：\r\n\r\n```python\r\n# -*- coding: utf-8 -*-\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n \r\n# 读取图像\r\nimg = cv2.imread('zxp.jpg')\r\nimg_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) #转成RGB 方便后面显示\r\n \r\n# 灰度化处理图像\r\ngrayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\n \r\n# Roberts算子\r\nkernelx = np.array([[-1, 0], [0, 1]], dtype=int)\r\nkernely = np.array([[0, -1], [1, 0]], dtype=int)\r\nx = cv2.filter2D(grayImage, cv2.CV_16S, kernelx)\r\ny = cv2.filter2D(grayImage, cv2.CV_16S, kernely)\r\n# 转uint8\r\nabsX = cv2.convertScaleAbs(x)\r\nabsY = cv2.convertScaleAbs(y)\r\nRoberts = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)\r\n \r\n# 用来正常显示中文标签\r\nplt.rcParams['font.sans-serif'] = ['SimHei']\r\n \r\n# 显示图形\r\n# titles = [u'原始图像', u'Roberts算子']\r\n# images = [img_RGB, Roberts]\r\n# for i in range(2):\r\n#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')\r\n#     plt.title(titles[i])\r\n#     plt.xticks([]), plt.yticks([])\r\n \r\n# plt.show()\r\n \r\n# 显示图形\r\nplt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭\r\nplt.subplot(122),plt.imshow(Roberts, cmap=plt.cm.gray ),plt.title('Roberts算子'), plt.axis('off')\r\nplt.show()\r\n```\r\n\r\n\r\n\r\n运行结果如下：\r\n\r\n![img](https://img-blog.csdnimg.cn/20190505145614311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Prewitt 算子\r\n\r\n**Prewitt算子**是一种图像边缘检测的微分算子，其原理是利用特定区域内像素灰度值产生的差分实现边缘检测。由于Prewitt算子采用3 x 3模板对区域内的像素值进行计算，而Robert算子的模板为2 x 2，故Prewitt算子的边缘检测结果在水平方向和垂直方向均比Robert算子更加明显。Prewitt算子适合用来识别噪声较多、灰度渐变的图像.\r\n\r\n其计算公式如下所示：\r\n\r\n![img](https://img-blog.csdnimg.cn/2019050510490374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)\r\n\r\n![{{g}_{y}}=\\frac{\\partial f}{\\partial y}=(\\text{P3+P6+P9)-}(\\text{P1+P4+P7)}](https://private.codecogs.com/gif.latex?%7B%7Bg%7D_%7By%7D%7D%3D%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20y%7D%3D%28%5Ctext%7BP3&plus;P6&plus;P9%29-%7D%28%5Ctext%7BP1&plus;P4&plus;P7%29%7D)\r\n\r\n\"\"\"\r\n\r\nopencv代码为:\r\n\r\n```python\r\n# -*- coding: utf-8 -*-\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n \r\n# 读取图像\r\nimg = cv2.imread('zxp.jpg')\r\nimg_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\r\n \r\n# 灰度化处理图像\r\ngrayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\n \r\n# Prewitt算子\r\nkernelx = np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]], dtype=int)\r\nkernely = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]], dtype=int)\r\nx = cv2.filter2D(grayImage, cv2.CV_16S, kernelx)\r\ny = cv2.filter2D(grayImage, cv2.CV_16S, kernely)\r\n# 转uint8\r\nabsX = cv2.convertScaleAbs(x)\r\nabsY = cv2.convertScaleAbs(y)\r\nPrewitt = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)\r\n \r\n# 用来正常显示中文标签\r\nplt.rcParams['font.sans-serif'] = ['SimHei']\r\n \r\n# 显示图形\r\n# titles = [u'原始图像', u'Prewitt算子']\r\n# images = [img_RGB, Prewitt]\r\n# for i in range(2):\r\n#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')\r\n#     plt.title(titles[i])\r\n#     plt.xticks([]), plt.yticks([])\r\n# plt.show()\r\n \r\n \r\n# 显示图形\r\nplt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭\r\nplt.subplot(122),plt.imshow(Prewitt, cmap=plt.cm.gray ),plt.title('Prewitt算子'), plt.axis('off')\r\nplt.show()\r\n```\r\n\r\n\r\n\r\n运行结果如下：\r\n\r\n![img](https://img-blog.csdnimg.cn/20190505150547498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)\r\n\r\n\r\n\r\n\r\n\r\n# Sobel 算子\r\n\r\n**Sobel算子**是一种用于边缘检测的离散微分算子，它结合了高斯平滑和微分求导。该算子用于计算图像明暗程度近似值，根据图像边缘旁边明暗程度把该区域内超过某个数的特定点记为边缘。Sobel算子在Prewitt算子的基础上增加了权重的概念，认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓。\r\n\r\nSobel算子根据像素点上下、左右邻点灰度加权差，在边缘处达到极值这一现象检测边缘。对噪声具有平滑作用，提供较为精确的边缘方向信息。因为Sobel算子结合了高斯平滑和微分求导（分化），因此结果会具有更多的抗噪性，当对精度要求不是很高时，Sobel算子是一种较为常用的边缘检测方法。\r\n\r\nSobel算子的边缘定位更准确，常用于噪声较多、灰度渐变的图像。其算法模板如下面的公式所示，其中dx表示水平方向dy表示为垂直方向。\r\n\r\n\r\n\r\n<img src=\"https://private.codecogs.com/gif.latex?%7B%7Bd%7D_%7Bx%7D%7D%3D%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%20-1%20%26%200%20%26%201%20%5C%5C%20-2%20%26%200%20%26%202%20%5C%5C%20-1%20%26%200%20%26%201%20%5C%5C%20%5Cend%7Bmatrix%7D%20%5Cright%5D%5Cbegin%7Bmatrix%7D%20%7B%7D%20%26%20%7B%7D%20%26%20%7B%7D%20%5C%5C%20%7B%7D%20%26%20%7B%7D%20%26%20%7B%7D%20%5C%5C%20%7B%7D%20%26%20%7B%7D%20%26%20%7B%7D%20%5C%5C%20%5Cend%7Bmatrix%7D%7B%7Bd%7D_%7By%7D%7D%3D%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%20-1%20%26%20-2%20%26%20-1%20%5C%5C%200%20%26%200%20%26%200%20%5C%5C%201%20%26%202%20%26%201%20%5C%5C%20%5Cend%7Bmatrix%7D%20%5Cright%5D\" alt=\"{{d}_{x}}=\\left[ \\begin{matrix} -1 & 0 & 1 \\\\ -2 & 0 & 2 \\\\ -1 & 0 & 1 \\\\ \\end{matrix} \\right]\\begin{matrix} {} & {} & {} \\\\ {} & {} & {} \\\\ {} & {} & {} \\\\ \\end{matrix}{{d}_{y}}=\\left[ \\begin{matrix} -1 & -2 & -1 \\\\ 0 & 0 & 0 \\\\ 1 & 2 & 1 \\\\ \\end{matrix} \\right]\" style=\"zoom: 150%;\" />\r\n\r\n例如，下面给出**Sobel算子**的**模板**，在**像素点P5处**x和y方向上的梯度大小gx和gy分别计算为：\r\n\r\n![img](https://img-blog.csdnimg.cn/20190505105302405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)\r\n\r\n![{{g}_{y}}=\\frac{\\partial f}{\\partial y}=(\\text{P3+2P6+P9)-}(\\text{P1+2P4+P7)}](https://private.codecogs.com/gif.latex?%7B%7Bg%7D_%7By%7D%7D%3D%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20y%7D%3D%28%5Ctext%7BP3&plus;2P6&plus;P9%29-%7D%28%5Ctext%7BP1&plus;2P4&plus;P7%29%7D)\r\n\r\n\r\n\r\n\r\n\r\nopencv代码如下：\r\n\r\n```python\r\n# -*- coding: utf-8 -*-\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n \r\n# 读取图像\r\nimg = cv2.imread('zxp.jpg')\r\nimg_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\r\n \r\n# 灰度化处理图像\r\ngrayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\n \r\n# Sobel算子\r\nx = cv2.Sobel(grayImage, cv2.CV_16S, 1, 0)  # 对x求一阶导\r\ny = cv2.Sobel(grayImage, cv2.CV_16S, 0, 1)  # 对y求一阶导\r\nabsX = cv2.convertScaleAbs(x)\r\nabsY = cv2.convertScaleAbs(y)\r\nSobel = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)\r\n \r\n# 用来正常显示中文标签\r\nplt.rcParams['font.sans-serif'] = ['SimHei']\r\n \r\n# # 显示图形\r\n# titles = [u'原始图像', u'Sobel算子']\r\n# images = [lenna_img, Sobel]\r\n# for i in xrange(2):\r\n#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')\r\n#     plt.title(titles[i])\r\n#     plt.xticks([]), plt.yticks([])\r\n# plt.show()\r\n \r\n# 显示图形\r\nplt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭\r\nplt.subplot(122),plt.imshow(Sobel, cmap=plt.cm.gray ),plt.title('Sobel算子'), plt.axis('off')\r\nplt.show()\r\n```\r\n\r\n\r\n\r\n运行结果如下:\r\n\r\n![img](https://img-blog.csdnimg.cn/20190505150839101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Laplacian 算子\r\n\r\n**拉普拉斯(Laplacian) 算子**是n维欧几里德空间中的一个**二阶微分算子**，常用于图像增强领域和边缘提取。它通过灰度差分计算邻域内的像素。\r\n\r\n其中，Laplacian算子**四邻域**模板如下所示：\r\n\r\n​                                       ![\\text{H}=\\left[ \\begin{matrix} 0 & -1 & 0 \\\\ -1 & 4 & -1 \\\\ 0 & -1 & 0 \\\\ \\end{matrix} \\right]](https://private.codecogs.com/gif.latex?%5Ctext%7BH%7D%3D%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%200%20%26%20-1%20%26%200%20%5C%5C%20-1%20%26%204%20%26%20-1%20%5C%5C%200%20%26%20-1%20%26%200%20%5C%5C%20%5Cend%7Bmatrix%7D%20%5Cright%5D)\r\n\r\nLaplacian算子的**八邻域**模板如下所示：\r\n\r\n​                                       ![\\text{H}=\\left[ \\begin{matrix} -1 & -1 & -1 \\\\ -1 & 8 & -1 \\\\ -1 & -1 & -1 \\\\ \\end{matrix} \\right]](https://private.codecogs.com/gif.latex?%5Ctext%7BH%7D%3D%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%20-1%20%26%20-1%20%26%20-1%20%5C%5C%20-1%20%26%208%20%26%20-1%20%5C%5C%20-1%20%26%20-1%20%26%20-1%20%5C%5C%20%5Cend%7Bmatrix%7D%20%5Cright%5D)\r\n\r\n\r\n\r\n通过Laplacian算子的模板可以发现：\r\n\r\n1）当邻域内像素灰度相同时，模板的卷积运算结果为0；\r\n\r\n2）当中心像素灰度高于邻域内其他像素的平均灰度时，模板的卷积运算结果为正数；\r\n\r\n3）当中心像素的灰度低于邻域内其他像素的平均灰度时，模板的卷积为负数。对卷积运算的结果用适当的衰弱因子处理并加在原中心像素上，就可以实现图像的锐化处理。\r\n\r\n\r\n\r\nopencv代码如下：\r\n\r\n```\r\n# -*- coding: utf-8 -*-\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n \r\n# 读取图像\r\nimg = cv2.imread('zxp.jpg')\r\nimg_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\r\n \r\n# 灰度化处理图像\r\ngrayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\n \r\n# 拉普拉斯算法\r\ndst = cv2.Laplacian(grayImage, cv2.CV_16S, ksize=3)\r\nLaplacian = cv2.convertScaleAbs(dst)\r\n \r\n# 用来正常显示中文标签\r\nplt.rcParams['font.sans-serif'] = ['SimHei']\r\n \r\n# # 显示图形\r\n# titles = [u'原始图像', u'Laplacian算子']\r\n# images = [lenna_img, Laplacian]\r\n# for i in xrange(2):\r\n#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')\r\n#     plt.title(titles[i])\r\n#     plt.xticks([]), plt.yticks([])\r\n# plt.show()\r\n \r\n \r\n# 显示图形\r\nplt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭\r\nplt.subplot(122),plt.imshow(Laplacian, cmap=plt.cm.gray ),plt.title('Laplacian算子'), plt.axis('off')\r\nplt.show()\r\n```\r\n\r\n\r\n\r\n运行结果如下：\r\n\r\n![img](https://img-blog.csdnimg.cn/20190505151151845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)\r\n\r\n\r\n\r\n\r\n\r\n## Canny算子\r\n\r\nCanny边缘检测算子是一种多级检测算法。1986年由John F. Canny提出，同时提出了边缘检测的三大准则：\r\n\r\n- 低错误率的边缘检测：检测算法应该精确地找到图像中的尽可能多的边缘，尽可能的减少漏检和误检。\r\n- 最优定位：检测的边缘点应该精确地定位于边缘的中心。\r\n- 图像中的任意边缘应该只被标记一次，同时图像噪声不应产生伪边缘。\r\n\r\n\r\n\r\nCanny边缘检测算法的实现较为复杂,主要分为以下步骤：\r\n\r\n- 高斯模糊\r\n\r\n- 计算梯度幅值和方向\r\n\r\n- 非极大值 抑制\r\n\r\n- 滞后阈值\r\n\r\n  \r\n\r\n```python\r\n\"\"\"\r\ncv2.Canny(image,            # 输入原图（必须为单通道图）\r\n          threshold1, \r\n          threshold2,       # 较大的阈值2用于检测图像中明显的边缘\r\n          [, edges[, \r\n          apertureSize[,    # apertureSize：Sobel算子的大小\r\n          L2gradient ]]])   # 参数(布尔值)：\r\n                              true： 使用更精确的L2范数进行计算（即两个方向的倒数的平方和再开放），\r\n                              false：使用L1范数（直接将两个方向导数的绝对值相加）。\r\n\"\"\"\r\n\r\nimport cv2\r\nimport numpy as np  \r\n \r\noriginal_img = cv2.imread(\"qingwen.png\", 0)\r\n\r\n# canny(): 边缘检测\r\nimg1 = cv2.GaussianBlur(original_img,(3,3),0)\r\ncanny = cv2.Canny(img1, 50, 150)\r\n\r\n# 形态学：边缘检测\r\n_,Thr_img = cv2.threshold(original_img,210,255,cv2.THRESH_BINARY)#设定红色通道阈值210（阈值影响梯度运算效果）\r\nkernel = cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))         #定义矩形结构元素\r\ngradient = cv2.morphologyEx(Thr_img, cv2.MORPH_GRADIENT, kernel) #梯度\r\n\r\ncv2.imshow(\"original_img\", original_img) \r\ncv2.imshow(\"gradient\", gradient) \r\ncv2.imshow('Canny', canny)\r\n\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n\r\n```\r\n\r\n\r\n\r\n运行结果如下：\r\n![](https://ganhan999.github.io//post-images/1604651229973.jpg)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## LOG 算子\r\n\r\nOG （ Laplacian of Gaussian ） 边缘检测算子是 David Courtnay Marr 和 Ellen Hildreth 在 1980 年共同提出的，也称为 Marr & Hildreth 算子，它根据图像的信噪比来求检测边缘的最优滤波器。该算法首先对图像做高斯滤波，然后再求其拉普拉斯（ Laplacian ）二阶导数，根据二阶导数的过零点来检测图像的边界，即通过检测滤波结果的零交叉（ Zero crossings ）来获得图像或物体的边缘。\r\n\r\nLOG 算子实际上是把 Gauss 滤波和 Laplacian 滤波结合了起来，先平滑掉噪声，再进行边缘检测。\r\n\r\nLOG 算子与视觉生理中的数学模型相似，因此在图像处理领域中得到了广泛的应用。\r\n\r\n它具有抗干扰能力强，边界定位精度高，边缘连续性好，能有效提取对比度弱的边界等特点。\r\n\r\n\r\n\r\n常见的 LOG 算子是5 x 5的模板\r\n\r\n![](https://ganhan999.github.io//post-images/1604651236093.png)\r\n\r\n\r\n\r\nLOG 算子到中心的距离与位置加权系数的关系曲线像墨西哥草帽的剖面，所以 LOG 算子也叫墨西哥草帽滤波器。\r\n\r\n![img](https://cdn.geekdigging.com/opencv/13/log_caomao.webp)\r\n\r\n\r\n\r\nopencv代码如下：\r\n\r\n```python\r\nimport cv2 as cv\r\nimport matplotlib.pyplot as plt\r\n\r\n# 读取图像\r\nimg = cv.imread(\"maliao.jpg\")\r\nrgb_img = cv.cvtColor(img, cv.COLOR_BGR2RGB)\r\n\r\ngray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)\r\n\r\n# 先通过高斯滤波降噪\r\ngaussian = cv.GaussianBlur(gray_img, (3, 3), 0)\r\n\r\n# 再通过拉普拉斯算子做边缘检测\r\ndst = cv.Laplacian(gaussian, cv.CV_16S, ksize=3)\r\nLOG = cv.convertScaleAbs(dst)\r\n\r\n# 用来正常显示中文标签\r\nplt.rcParams['font.sans-serif'] = ['SimHei']\r\n\r\n# 显示图形\r\ntitles = ['原始图像', 'LOG 算子']\r\nimages = [rgb_img, LOG]\r\n\r\nfor i in range(2):\r\n    plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')\r\n    plt.title(titles[i])\r\n    plt.xticks([]), plt.yticks([])\r\nplt.show()\r\n```\r\n\r\n\r\n\r\n运行结果如下:\r\n\r\n![img](https://cdn.geekdigging.com/opencv/13/log_result.png)\r\n\r\n\r\n\r\n\r\n\r\n# DOG 算子\r\n\r\nDoG算子是高斯函数的差分，具体到图像中，就是将图像在不同参数下的高斯滤波结果相减，得到差分图。DoG算子的表达式如下：\r\n\r\n![](https://ganhan999.github.io//post-images/1604651116794.png)\r\n\r\n其中 k−1是个常数，不影响极值点的检测，LoG算子和DoG算子的函数波形对比如下图所示，由于高斯差分的计算更加简单，因此可用DoG算子近似替代LoG算子。\r\n\r\n<img src=\"https://i.loli.net/2017/12/18/5a3741bdd1528.jpg\" alt=\"LoG-DoG.jpg\" style=\"zoom:200%;\" />\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "边缘检测算子汇总",
        "date": "2020-11-06 16:04:00",
        "tags": [
          "数字图像处理"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/边缘检测算子汇总.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "边缘检测算子汇总"
    },
    {
      "content": "\r\n\r\n# 题目\r\n\r\n\"\"\"\r\n给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\r\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\r\n\r\n示例 1:\r\n给定数组 nums = [1,1,2],\r\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。\r\n你不需要考虑数组中超出新长度后面的元素。\r\n\r\n示例 2:\r\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\r\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\r\n你不需要考虑数组中超出新长度后面的元素。\r\n\r\n\"\"\"\r\n\r\n# 本体思路\r\n\r\n\r\n\r\n因为是有序序列，只需要前一个与后一个比较即可，并不麻烦\r\n\r\n\r\n\r\n\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        i=0\r\n        if len(nums)==0 or len(nums)==1:\r\n            return len(nums)\r\n        else:\r\n            while(i<len(nums)-1):\r\n                if nums[i]==nums[i+1]:\r\n                    nums.pop(i)\r\n                else:\r\n                    i=i+1\r\n        return len(nums)\r\n\r\n```\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n# 大神做法：\r\n\r\n双指针法：题意可以理解为直接修改前k个数，因此无需删除操作\r\n\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        a = 0\r\n        b = 1\r\n        while b < len(nums):\r\n            if nums[b] == nums[a]:\r\n                b += 1\r\n            else:\r\n                a += 1\r\n                nums[a] = nums[b]\r\n        return a+1\r\n\r\n\r\n#复现成功！\r\n```\r\n\r\n\r\n\r\n\r\n\r\npython中关于删除list中的某个元素，一般有三种方法:remove、pop、del：\r\n\r\n\r\n\r\n```python\r\n1.remove: 删除单个元素，删除首个符合条件的元素，按值删除\r\n举例说明:\r\n\r\n>>> str=[1,2,3,4,5,2,6]\r\n>>> str.remove(2)\r\n>>> str\r\n[1, 3, 4, 5, 2, 6]\r\n\r\n \r\n\r\n2.pop: 删除单个或多个元素，按位删除(根据索引删除)\r\n\r\n>>> str=[0,1,2,3,4,5,6]\r\n>>> str.pop(1) #pop删除时会返回被删除的元素\r\n>>> str\r\n[0, 2, 3, 4, 5, 6]\r\n\r\n \r\n\r\n>>> str2=['abc','bcd','dce']\r\n>>> str2.pop(2)\r\n'dce'\r\n>>> str2\r\n['abc', 'bcd']\r\n\r\n \r\n\r\n3.del：它是根据索引(元素所在位置)来删除\r\n举例说明:\r\n\r\n>>> str=[1,2,3,4,5,2,6]\r\n>>> del str[1]\r\n>>> str\r\n[1, 3, 4, 5, 2, 6]\r\n\r\n \r\n\r\n>>> str2=['abc','bcd','dce']\r\n>>> del str2[1]\r\n>>> str2\r\n['abc', 'dce']\r\n\r\n \r\n\r\n除此之外，del还可以删除指定范围内的值。\r\n\r\n>>> str=[0,1,2,3,4,5,6]\r\n>>> del str[2:4] #删除从第2个元素开始，到第4个为止的元素(但是不包括尾部元素)\r\n>>> str\r\n[0, 1, 4, 5, 6]\r\n\r\n \r\n\r\ndel 也可以删除整个数据对象(列表、集合等)\r\n\r\n>>> str=[0,1,2,3,4,5,6]\r\n>>> del str\r\n>>> str #删除后，找不到对象\r\n   \r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "26、删除排序数组中的重复项",
        "date": "2020-11-05 21:04:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/26、删除排序数组中的重复项.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "26、删除排序数组中的重复项"
    },
    {
      "content": "\r\n\r\n# 题目\r\n\r\n\"\"\"\r\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \r\n示例：\r\n输入：1->2->4, 1->3->4\r\n输出：1->1->2->3->4->4\r\n\r\n\"\"\"\r\n\r\n# 本体思路\r\n\r\n\r\n\r\n创建一个新链表，将小的那个值依次填入新链表的next中，直到一个链表为空后，直接将另外一个链表填入新链表的next中。\r\n值得一提的是必须需要建立一个哑节点，不然新链表在执行的时候端点会跑到后面去。\r\n这道题非常类似与归并排序\r\n\r\n\r\n\r\n\r\n# #我的做法：\r\n\r\n```python\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\nclass Solution:\r\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\r\n        newlist=ListNode(0)#起始值为0，没有任何意义，下一个next才是开始。\r\n        yajiedian = newlist#哑巴节点\r\n        while l1 and l2 :\r\n            if l1.val<=l2.val:\r\n                newlist.next=l1#可以使用这样更快的方式运行  node.next,l1 = l1,l1.next\r\n                l1=l1.next\r\n            else:\r\n                newlist.next=l2#node.next,l2 = l2,l2.next\r\n                l2=l2.next\r\n            newlist=newlist.next\r\n        if l1:\r\n            newlist.next=l1\r\n        else:\r\n            newlist.next=l2\r\n        return yajiedian.next\r\n\r\n```\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n# 大神做法：\r\n\r\n利用递归，把最小的那个值取出来赋给L1，然后到最后会有一个链表为空，于是把那个链表直接赋给l1\r\n\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\r\n        # 递归\r\n        if l1 and l2:\r\n            if l1.val > l2.val:\r\n                l1, l2 = l2, l1\r\n            l1.next = self.mergeTwoLists(l1.next, l2)\r\n        return l1 or l2\r\n\r\n#复现成功！\r\n```\r\n\r\n\r\n\r\n\r\n\r\npython没有指针哪来的链表？\r\n\r\n\r\n\r\n```python\r\n\r\nclass Node(object):\r\n    #节点\r\n    def __init__(self, val):\r\n        self.val = val#节点的值\r\n        self.next = None#节点的指针（指向下一个Node）\r\n        \r\n在大神做法中，print出来的链表形式是这样的。\r\nNone\r\nListNode{val: 4, next: ListNode{val: 4, next: None}}\r\nListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 4, next: None}}}\r\nListNode{val: 2, next: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 4, next: None}}}}\r\nListNode{val: 1, next: ListNode{val: 2, next: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 4, next: None}}}}}\r\nListNode{val: 1, next: ListNode{val: 1, next: ListNode{val: 2, next: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 4, next: None}}}}}}\r\n```\r\n\r\n![](https://ganhan999.github.io//post-images/1604582353766.png)\r\n\r\n\r\n\r\npython链表介绍\r\n\r\n```python\r\n#链表的初始化\r\nclass Node(object):\r\n    \"\"\"节点\"\"\"\r\n    def __init__(self, elem):\r\n        self.elem = elem\r\n        self.next = None\r\n        \r\n#链表封装的一系列操作\r\nclass SingleLinkList(object):\r\n    \"\"\"单链表\"\"\"\r\n    def __init__(self, node=None):\r\n        self.__head = node\r\n\r\n    def is_empty(self):\r\n        \"\"\"链表是否为空\"\"\"\r\n        return self.__head == None\r\n\r\n    def length(self):\r\n        \"\"\"链表长度\"\"\"\r\n        # cur游标，用来移动遍历节点\r\n        cur = self.__head\r\n        # count记录数量\r\n        count = 0\r\n        while cur != None:\r\n            count += 1\r\n            cur = cur.next\r\n        return count\r\n\r\n    def travel(self):\r\n        \"\"\"遍历整个链表\"\"\"\r\n        cur = self.__head\r\n        while cur != None:\r\n            print(cur.elem, end=\" \")\r\n            cur = cur.next\r\n        print(\"\")\r\n\r\n    def add(self, item):\r\n        \"\"\"链表头部添加元素，头插法\"\"\"\r\n        node = Node(item)\r\n        node.next = self.__head\r\n        self.__head = node\r\n\r\n    def append(self, item):\r\n        \"\"\"链表尾部添加元素, 尾插法\"\"\"\r\n        node = Node(item)\r\n        if self.is_empty():\r\n            self.__head = node\r\n        else:\r\n            cur = self.__head\r\n            while cur.next != None:\r\n                cur = cur.next\r\n            cur.next = node\r\n\r\n    def insert(self, pos, item):\r\n        \"\"\"指定位置添加元素\r\n        :param  pos 从0开始\r\n        \"\"\"\r\n        if pos <= 0:\r\n            self.add(item)\r\n        elif pos > (self.length()-1):\r\n            self.append(item)\r\n        else:\r\n            pre = self.__head\r\n            count = 0\r\n            while count < (pos-1):\r\n                count += 1\r\n                pre = pre.next\r\n            # 当循环退出后，pre指向pos-1位置\r\n            node = Node(item)\r\n            node.next = pre.next\r\n            pre.next = node\r\n\r\n    def remove(self, item):\r\n        \"\"\"删除节点\"\"\"\r\n        cur = self.__head\r\n        pre = None\r\n        while cur != None:\r\n            if cur.elem == item:\r\n                # 先判断此结点是否是头节点\r\n                # 头节点\r\n                if cur == self.__head:\r\n                    self.__head = cur.next\r\n                else:\r\n                    pre.next = cur.next\r\n                break\r\n            else:\r\n                pre = cur\r\n                cur = cur.next\r\n\r\n    def search(self, item):\r\n        \"\"\"查找节点是否存在\"\"\"\r\n        cur = self.__head\r\n        while cur != None:\r\n            if cur.elem == item:\r\n                return True\r\n            else:\r\n                cur = cur.next\r\n        return False\r\n```\r\n\r\n",
      "data": {
        "title": "21、合并两个有序列表",
        "date": "2020-11-04 21:54:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/21、合并两个有序链表.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "21、合并两个有序链表"
    },
    {
      "content": "\r\n\r\n# 题目\r\n\r\n\"\"\"\r\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\r\n\r\n有效字符串需满足：\r\n\r\n左括号必须用相同类型的右括号闭合。\r\n左括号必须以正确的顺序闭合。\r\n注意空字符串可被认为是有效字符串。\r\n示例 1:\r\n输入: \"()\"\r\n输出: true\r\n\r\n示例 2:\r\n输入: \"()[]{}\"\r\n输出: true\r\n\r\n示例 3:\r\n输入: \"(]\"\r\n输出: false\r\n\r\n示例 4:\r\n输入: \"([)]\"\r\n输出: false\r\n\r\n示例 5:\r\n输入: \"{[]}\"\r\n输出: true\r\n\r\n\"\"\"\r\n\r\n# 本体思路\r\n\r\n\r\n\r\n这个题显然就要用到栈的知识，如果输入的是一个右边括号，如果他与栈顶的元素不对应时，则返回False，如果对应则弹出，\r\n直到操作结束，判断栈是否为空。\r\n![](https://ganhan999.github.io//post-images/1604376185870.gif)\r\n\r\n\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution:\r\n    def isValid(self, s: str) -> bool:\r\n        dic={')':'(',']':'[','}':'{'}\r\n        stack=[]\r\n        for ele in s:\r\n            if stack and ele in dic:\r\n                if dic[ele]==stack[-1]:\r\n                    stack.pop()\r\n                else:return False\r\n            else:\r\n                stack.append(ele)\r\n        return not stack\r\n\r\n```\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n# 大神做法：\r\n\r\n对于正确的来说，每次都能去掉一对括号，最后就成了空\r\n\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def isValid(self, s: str) -> bool:\r\n        while '{}' in s or '()' in s or '[]' in s:\r\n            s = s.replace('{}', '')\r\n            s = s.replace('[]', '')\r\n            s = s.replace('()', '')\r\n        return s == ''\r\n\r\n#复现成功！\r\n```\r\n\r\n\r\n\r\n\r\n\r\n如何使列表最后一个元素弹出\r\n![](https://ganhan999.github.io//post-images/1604376165952.png)\r\n\r\n总结：\r\n以上三种方法未在内存处理上进行测试，唯一区别，pop方法和del方法如果对空列表进行操作，会报错中断执行，切片方法不会因此报错，继续保持空列表向下运行\r\n\r\n\r\n\r\n",
      "data": {
        "title": "20、有效的括号",
        "date": "2020-11-03 12:03:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/20、有效的括号.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "20、有效的括号"
    },
    {
      "content": "\r\n心得个鬼，就一直刷一直刷，刷到你能每次模拟考都过90为止！\r\n气死我了为什么我第一次每次都过不了90！\r\n明天一定一次过90！😤😤😤",
      "data": {
        "title": "科目一心得",
        "date": "2020-11-03 00:11:48",
        "tags": [
          "生活日常"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/ke-mu-yi-xin-de.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ke-mu-yi-xin-de"
    },
    {
      "content": "\r\n# 题目\r\n\r\n\"\"\"\r\n编写一个函数来查找字符串数组中的最长公共前缀。\r\n如果不存在公共前缀，返回空字符串 \"\"。\r\n示例 1:\r\n输入: [\"flower\",\"flow\",\"flight\"]\r\n输出: \"fl\"\r\n示例 2:\r\n输入: [\"dog\",\"racecar\",\"car\"]\r\n输出: \"\"\r\n解释: 输入不存在公共前缀。\r\n说明:\r\n所有输入只包含小写字母 a-z 。\r\n\r\n\"\"\"\r\n\r\n# 本体思路\r\n\r\n\r\n\r\n首先样例可能有\r\n🌰1、\"a\",\"b\" \r\n🌰2、\"a\",\"\"\r\n🌰3、\"ab\",\"a\"\r\n🌰4、\"abbba\",\"abbba\"\r\n🌰5、\"\"\r\n这几种特殊情况，首先分析，如果空列表，就直接输出“”,例如🌰5。\r\n其次如果出现🌰2这种情况，那么就要算出最小值如果是0，那么输出“”。\r\n先算出最大可能前缀为a( (min(strs, key=lambda i: len(i)))) ，然后遍历所有列表的元素ele，进行比较。\r\n注意如果出现了🌰4，那么就需要在最后return  strs[0][:i+1]。\r\n其他情况下return strs[0][:i]，因为比较完的下一个不是相同前缀。\r\n以后一定要记得先举例子分析！！！！\r\n\r\n\r\n\r\n# #我的做法（超级傻逼，遇到了很多困难）：\r\n\r\n```python\r\nclass Solution:\r\n    def longestCommonPrefix(self, strs: List[str]) -> str:\r\n        if not strs :\r\n            return ''\r\n        a = (min(strs, key=lambda i: len(i)))\r\n        n = len(a)\r\n        if n==0 :\r\n            return a\r\n        for i in range(n):\r\n            c=strs[0][i]\r\n            for ele in strs:\r\n                if ele[i]==c:\r\n                    continue\r\n                else:\r\n                        break\r\n            else:\r\n                continue\r\n            return strs[0][:i]\r\n        return  strs[0][:i+1]\r\n```\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n# 大神做法：\r\n\r\npython两种让你拍大腿的解法，时间复杂度你想象不到，短小精悍。 \r\n1、利用python的max()和min()，在Python里字符串是可以比较的，\r\n按照ascII值排，举例abb， aba，abac，最大为abb，最小为aba。\r\n所以只需要比较最大最小的公共前缀就是整个数组的公共前缀(太妙了！！！）\r\n\r\n2、利用python的zip函数，把str看成list然后把输入看成二维数组，\r\n左对齐纵向压缩，然后把每项利用集合去重，之后遍历list中找到元素\r\n长度大于1之前的就是公共前缀（天才，灵活运用函数！）\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def longestCommonPrefix(self, strs: List[str]) -> str:\r\n        if not strs: return \"\"\r\n        s1 = min(strs)#利用ASCII码，最大和最小的比就行了。天才！\r\n        s2 = max(strs)\r\n        for i,x in enumerate(s1):\r\n            if x != s2[i]:\r\n                return s2[:i]\r\n        return s1\r\n\r\n#复现成功！\r\n```\r\n\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def longestCommonPrefix(self, strs: List[str]) -> str:\r\n        if not strs: return \"\"\r\n        ss = list(map(set, zip(*strs)))#这里zip(*strs)是一个迭代器，如果list出来则是\r\n                        # [('a', 'a', 'a'), ('b', 'b', 'b'), ('b', 'a', 'c'), ('a', 'a', 'a')]\r\n                      #相当于二维数组左对齐，然后用set map一下，就变成”a“，”b“，”b，a，c“，”a“。然后算出长度就行了。\r\n        res = \"\"\r\n        for i, x in enumerate(ss):\r\n            x = list(x)\r\n            if len(x) > 1:\r\n                break\r\n            res = res + x[0]\r\n        return res\r\n        \r\n #复现成功！\r\n```\r\n\r\n\r\n\r\n如何跳出双重循环？\r\n\r\n```python\r\nfor i in range(5):\r\n  for j in range(5):\r\n    print(i, j)\r\n    if i == 3 and j == 3:\r\n      break\r\n  else:\r\n    continue\r\n  break\r\n```\r\n\r\n\r\n\r\n下面是zip函数的介绍\r\n\r\n![](https://ganhan999.github.io//post-images/1604333260016.png)\r\n\r\n\r\n下面是 enumerate函数介绍\r\n\r\n![](https://ganhan999.github.io//post-images/1604333288960.png)\r\n![](https://ganhan999.github.io//post-images/1604333292784.jpg)\r\n\r\n",
      "data": {
        "title": "14、最长公共前缀",
        "date": "2020-11-03 00:03:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/14、最长公共前缀 .jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "14、最长公共前缀 "
    },
    {
      "content": "常见的256级灰度图片中，每个像素灰度值由8个比特组成，分别将这8个比特分离，形成8幅新的图片，称为比特图像分层。\r\n\r\n举个🌰：\r\n\r\n有一副四个像素（2*2）的图像，像素值分别为1，2，3，4：\r\n![](https://ganhan999.github.io//post-images/1604302386613.gif)\r\n                                                                            \r\n\r\n 这些值转换为二进制为（扩充为8位）：1（00000001）2（00000010）3（00000011）4（00000100）\r\n\r\n则这幅图像的8个比特层图像为：\r\n![](https://ganhan999.github.io//post-images/1604302400912.gif)\r\n\r\n\r\n\r\n\r\n实例：\r\n![](https://ganhan999.github.io//post-images/1604303058038.png)\r\n读取图片数据：\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\n#更改为需要的图片路径\r\nimg = cv2.imread(r'1.png',0)\r\nh,w = img.shape[0],img.shape[1]\r\n\r\n#处理过程\r\nnew_img = np.zeros((h,w,8))\r\nfor i in range(h):\r\n    for j in range(w):\r\n        n = str(np.binary_repr(img[i,j],8))\r\n        for k in range(8):\r\n            new_img[i,j,k] = n[k]\r\n\r\n#依次显示\r\nfor i in range(8):\r\n    cv2.imshow('image',new_img[:,:,i])\r\n    cv2.waitKey(0)\r\n```\r\n\r\n \r\n结果如下(比特层数递增，最后一张是原图)：\r\n![](https://ganhan999.github.io//post-images/1604302544079.jpg)\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "比特图像分层",
        "date": "2020-11-02 15:32:29",
        "tags": [
          "数字图像处理"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/比特平面分层.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "比特平面分层"
    },
    {
      "content": "\r\n\r\n# 题目\r\n\r\n\"\"\"\r\n\r\n罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\r\n\r\n字符          数值\r\nI             1\r\nV             5\r\nX             10\r\nL             50\r\nC             100\r\nD             500\r\nM             1000\r\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\r\n\r\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\r\n\r\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\r\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \r\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\r\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\r\n\"\"\"\r\n\r\n# 本体思路\r\n\r\n\r\n\r\n这题懂了就非常简单。首先建立一个HashMap来映射符号和值，然后对字符串从左到右来，\r\n如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。\r\n以此类推到最左边的数，最终得到的结果即是答案\r\n\r\n\r\n\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution:\r\n    def romanToInt(self, s: str) -> int:\r\n        a = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,\"0\":0}\r\n        lens = len(s)\r\n        print('lens=',lens)\r\n        sum = 0\r\n        s=s+\"0\"\r\n        print(s)\r\n        if lens == 1:\r\n            return sum + a[s[0]]\r\n        for i in range(lens):\r\n            if a[s[i]] < a[s[i+1]] :\r\n                sum = sum - a[s[i]]#前面比后面大 就取负数\r\n            else :\r\n                sum=sum+a[s[i]]\r\n        return sum\r\n```\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n# 大神做法：\r\n\r\nif i<lens-1 and a[s[i]] < a[s[i+1]]:#把i<lens-1放前面，可以导致后面的断路！\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def romanToInt(self, s: str) -> int:\r\n        a = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\r\n        lens = len(s)\r\n        print('lens=',lens)\r\n        sum = 0\r\n        for i in range(lens):\r\n            if i<lens-1 and a[s[i]] < a[s[i+1]]:#把i<lens-1放前面，可以导致后面的断路！\r\n                sum = sum - a[s[i]]\r\n            else :\r\n                sum=sum+a[s[i]]\r\n        return sum\r\n\r\n#复现成功！\r\n```\r\n\r\n",
      "data": {
        "title": "13、罗马数字转整数",
        "date": "2020-11-02 11:45:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/13、罗马数字转整数.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "13、罗马数字转整数"
    },
    {
      "content": "\r\n\r\n# 题目\r\n\r\n\"\"\"\r\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\"\"\"\r\n\"\"\"\r\n\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution:\r\n    def isPalindrome(self, x: int) -> bool:\r\n        x1=x\r\n        y=0\r\n        if x<0:\r\n            return False\r\n        while(x!=0):\r\n            y=y*10+x%10\r\n            x=int(x/10)\r\n        return y==x1#精髓啊！\r\n```\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n# 大神做法：\r\n\r\n\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def isPalindrome(self, x: int) -> bool:\r\n        return str(x) == str(x)[::-1]#str(x)[::-1]是反转数\r\n\r\n#复现成功！\r\n```\r\n\r\n",
      "data": {
        "title": "9、回文数",
        "date": "2020-11-02 11:40:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/9、回文数.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "9、回文数"
    },
    {
      "content": "\r\n\r\n# 题目\r\n\r\n\"\"\"\r\n给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\"\"\"\r\n\"\"\"\r\n\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution1:\r\n    def reverse(self, x: int) -> int:\r\n        lis=str(x)\r\n        lis=list(lis)\r\n        if lis[0]=='-':\r\n            lis1=lis[1:]\r\n            lis1.reverse()\r\n            lis1=list('-')+lis1\r\n        else:\r\n            lis1=lis[:]\r\n            lis1.reverse()\r\n        result =int( \"\".join(lis1))\r\n        if -2**31<result<2**31-1:\r\n            return result\r\n        return 0\r\n```\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n# #我的做法2\r\n\r\n\r\n\"\"\"\r\n\r\n```python\r\nclass Solution2:\r\n    def reverse(self, x: int) -> int:\r\n        flag=0\r\n        y=0\r\n        if x<0:\r\n            flag=1\r\n        x=abs(x)\r\n        while(x!=0):\r\n            y=y*10+x%10\r\n            x=int(x/10)\r\n            if (-2 ** 31 < y < 2 ** 31 - 1) is False:\r\n                return 0\r\n        return 0-y if flag==1 else y\r\n\r\n```\r\n![](https://ganhan999.github.io//post-images/1604294970545.jpg)\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "7、整数反转",
        "date": "2020-11-02 11:35:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/7、整数反转.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "7、整数反转"
    },
    {
      "content": "\r\n\r\n# 题目\r\n\r\n\"\"\"\r\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\r\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\r\n\"\"\"\r\n\r\n# #我的做法：\r\n\r\n```python\r\nclass Solution:\r\n    def twoSum(self,nums,target):\r\n        len1=len(nums)\r\n        for i in range(len1):\r\n            j=i+1\r\n            for j in range(j,len1):\r\n              if nums[i]+nums[j]==target:\r\n                  return [i,j]\r\n        return [0,0]\r\n```\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n# 大神做法：\r\n\r\n参考了大神们的解法，通过哈希来求解，这里通过字典来模拟哈希查询的过程。\r\n个人理解这种办法相较于方法一其实就是字典记录了 num1 和 num2 的值和位置，而省了再查找 num2 索引的步骤。\r\n用枚举的方式，构造哈希表\r\n\"\"\"\r\n\r\n```python\r\nclass Solution:\r\n    def twoSum(self,nums, target):\r\n        hashmap={}\r\n        for i,j in enumerate(nums):\r\n            hashmap[j]=i\r\n        for n,m in enumerate(nums):\r\n            number=hashmap.get(target-m)\r\n            if number is not None and n!=number:\r\n                return[n,number]\r\n        return[0,0]\r\n\r\n#复现成功！\r\n```\r\n\r\n",
      "data": {
        "title": "1、两数之和",
        "date": "2020-11-02 11:21:00",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/1、两数之和.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "1、两数之和"
    },
    {
      "content": "从今天开始当一个长远打算的人\r\n但是目前我还是没有想好\r\n到底是考公、算法、开发、读博当老师？\r\n纠结的离谱🤡",
      "data": {
        "title": "今天是记录博客的第一天",
        "date": "2020-11-01 22:39:31",
        "tags": [
          "生活日常"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/生活.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "今天是记录博客的第一天"
    },
    {
      "content": "![](https://ganhan999.github.io//post-images/1605005386891.png)> 欢迎来到我的小站呀，很高兴遇见你！🤝\n\n## 🏠 关于本站\n这是甘晗的博客主站~以后会分享我的学习和生活简历，感谢各位来踩\n\n## 👨‍💻 博主是谁\n博主是甘晗\n\n## ⛹ 兴趣爱好\n乒乓球、LOL\n\n## 📬 联系我呀\n不方便噢~",
      "data": {
        "title": "本站相关",
        "date": "2019-01-25 19:09:48",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \n\n<!-- more -->\n\n[Github](https://github.com/getgridea/gridea)  \n[Gridea 主页](https://gridea.dev/)  \n[示例网站](http://fehey.com/)\n\n## 特性👇\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \n\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \n\n🏷️  你可以对文章进行标签分组  \n\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \n\n💻  你可以在 **Windows**，**MacOS** 或 **Linux** 设备上使用此客户端  \n\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \n\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \n\n🇬🇧  你可以使用**中文简体**或**英语**  \n\n🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  \n\n🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  \n\n🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前 🏃\n\n未来，它一定会成为你离不开的伙伴\n\n尽情发挥你的才华吧！\n\n😘 Enjoy~\n",
      "data": {
        "title": "Hello Gridea",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "Gridea"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/gridea.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... ",
      "fileName": "hello-gridea"
    }
  ],
  "tags": [
    {
      "index": -1,
      "name": "数字图像处理",
      "slug": "Srrvj4WNi",
      "used": true
    },
    {
      "index": -1,
      "name": "生活日常",
      "slug": "-qdqMhERP",
      "used": true
    },
    {
      "index": -1,
      "name": "leetcode",
      "slug": "ILhkuZd6D",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "Zouo1jPZV",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "本站相关",
      "openType": "Internal"
    }
  ]
}