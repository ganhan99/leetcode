---
title: '边缘检测算子汇总'
date: 2020-11-06 16:04:00
tags: [数字图像处理]
published: true
hideInList: false
feature: /post-images/边缘检测算子汇总.jpg
isTop: false
---


# 边缘检测


边缘检测是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。图像属性中的显著变化通常反映了属性的重要事件和变化。这些包括：深度上的不连续、表面方向不连续、物质属性变化和场景照明变化。 





# 检测思路



图像的边缘有方向和幅度两种属性。边缘通常可以通过**一阶导数**或**二阶导数**检测得到。**一阶导数**是以**最大值**作为对应的边缘的位置，而**二阶导数**则以**过零点**作为对应边缘的位置。







# Roberts 算子

**Roberts算子**又称为交叉微分算法，它是基于交叉差分的梯度算法，通过局部差分计算检测边缘线条。常用来处理具有陡峭的低噪声图像，当图像边缘接近于正45度或负45度时，该算法处理效果更理想。其缺点是对边缘的定位不太准确，提取的边缘线条较粗。



下面给出**Roberts算子**的**模板**，在**像素点P5处** x 和 y 方向上的梯度大小gx和gy

![img](https://img-blog.csdnimg.cn/20190505104614320.png)
![](https://ganhan999.github.io//post-images/1604651076241.png)
opencv代码为：

```python
# -*- coding: utf-8 -*-
import cv2
import numpy as np
import matplotlib.pyplot as plt
 
# 读取图像
img = cv2.imread('zxp.jpg')
img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) #转成RGB 方便后面显示
 
# 灰度化处理图像
grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
 
# Roberts算子
kernelx = np.array([[-1, 0], [0, 1]], dtype=int)
kernely = np.array([[0, -1], [1, 0]], dtype=int)
x = cv2.filter2D(grayImage, cv2.CV_16S, kernelx)
y = cv2.filter2D(grayImage, cv2.CV_16S, kernely)
# 转uint8
absX = cv2.convertScaleAbs(x)
absY = cv2.convertScaleAbs(y)
Roberts = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)
 
# 用来正常显示中文标签
plt.rcParams['font.sans-serif'] = ['SimHei']
 
# 显示图形
# titles = [u'原始图像', u'Roberts算子']
# images = [img_RGB, Roberts]
# for i in range(2):
#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')
#     plt.title(titles[i])
#     plt.xticks([]), plt.yticks([])
 
# plt.show()
 
# 显示图形
plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭
plt.subplot(122),plt.imshow(Roberts, cmap=plt.cm.gray ),plt.title('Roberts算子'), plt.axis('off')
plt.show()
```



运行结果如下：

![img](https://img-blog.csdnimg.cn/20190505145614311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)







# Prewitt 算子

**Prewitt算子**是一种图像边缘检测的微分算子，其原理是利用特定区域内像素灰度值产生的差分实现边缘检测。由于Prewitt算子采用3 x 3模板对区域内的像素值进行计算，而Robert算子的模板为2 x 2，故Prewitt算子的边缘检测结果在水平方向和垂直方向均比Robert算子更加明显。Prewitt算子适合用来识别噪声较多、灰度渐变的图像.

其计算公式如下所示：

![img](https://img-blog.csdnimg.cn/2019050510490374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)

![{{g}_{y}}=\frac{\partial f}{\partial y}=(\text{P3+P6+P9)-}(\text{P1+P4+P7)}](https://private.codecogs.com/gif.latex?%7B%7Bg%7D_%7By%7D%7D%3D%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20y%7D%3D%28%5Ctext%7BP3&plus;P6&plus;P9%29-%7D%28%5Ctext%7BP1&plus;P4&plus;P7%29%7D)

"""

opencv代码为:

```python
# -*- coding: utf-8 -*-
import cv2
import numpy as np
import matplotlib.pyplot as plt
 
# 读取图像
img = cv2.imread('zxp.jpg')
img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
 
# 灰度化处理图像
grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
 
# Prewitt算子
kernelx = np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]], dtype=int)
kernely = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]], dtype=int)
x = cv2.filter2D(grayImage, cv2.CV_16S, kernelx)
y = cv2.filter2D(grayImage, cv2.CV_16S, kernely)
# 转uint8
absX = cv2.convertScaleAbs(x)
absY = cv2.convertScaleAbs(y)
Prewitt = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)
 
# 用来正常显示中文标签
plt.rcParams['font.sans-serif'] = ['SimHei']
 
# 显示图形
# titles = [u'原始图像', u'Prewitt算子']
# images = [img_RGB, Prewitt]
# for i in range(2):
#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')
#     plt.title(titles[i])
#     plt.xticks([]), plt.yticks([])
# plt.show()
 
 
# 显示图形
plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭
plt.subplot(122),plt.imshow(Prewitt, cmap=plt.cm.gray ),plt.title('Prewitt算子'), plt.axis('off')
plt.show()
```



运行结果如下：

![img](https://img-blog.csdnimg.cn/20190505150547498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)





# Sobel 算子

**Sobel算子**是一种用于边缘检测的离散微分算子，它结合了高斯平滑和微分求导。该算子用于计算图像明暗程度近似值，根据图像边缘旁边明暗程度把该区域内超过某个数的特定点记为边缘。Sobel算子在Prewitt算子的基础上增加了权重的概念，认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓。

Sobel算子根据像素点上下、左右邻点灰度加权差，在边缘处达到极值这一现象检测边缘。对噪声具有平滑作用，提供较为精确的边缘方向信息。因为Sobel算子结合了高斯平滑和微分求导（分化），因此结果会具有更多的抗噪性，当对精度要求不是很高时，Sobel算子是一种较为常用的边缘检测方法。

Sobel算子的边缘定位更准确，常用于噪声较多、灰度渐变的图像。其算法模板如下面的公式所示，其中dx表示水平方向dy表示为垂直方向。



<img src="https://private.codecogs.com/gif.latex?%7B%7Bd%7D_%7Bx%7D%7D%3D%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%20-1%20%26%200%20%26%201%20%5C%5C%20-2%20%26%200%20%26%202%20%5C%5C%20-1%20%26%200%20%26%201%20%5C%5C%20%5Cend%7Bmatrix%7D%20%5Cright%5D%5Cbegin%7Bmatrix%7D%20%7B%7D%20%26%20%7B%7D%20%26%20%7B%7D%20%5C%5C%20%7B%7D%20%26%20%7B%7D%20%26%20%7B%7D%20%5C%5C%20%7B%7D%20%26%20%7B%7D%20%26%20%7B%7D%20%5C%5C%20%5Cend%7Bmatrix%7D%7B%7Bd%7D_%7By%7D%7D%3D%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%20-1%20%26%20-2%20%26%20-1%20%5C%5C%200%20%26%200%20%26%200%20%5C%5C%201%20%26%202%20%26%201%20%5C%5C%20%5Cend%7Bmatrix%7D%20%5Cright%5D" alt="{{d}_{x}}=\left[ \begin{matrix} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \\ \end{matrix} \right]\begin{matrix} {} & {} & {} \\ {} & {} & {} \\ {} & {} & {} \\ \end{matrix}{{d}_{y}}=\left[ \begin{matrix} -1 & -2 & -1 \\ 0 & 0 & 0 \\ 1 & 2 & 1 \\ \end{matrix} \right]" style="zoom: 150%;" />

例如，下面给出**Sobel算子**的**模板**，在**像素点P5处**x和y方向上的梯度大小gx和gy分别计算为：

![img](https://img-blog.csdnimg.cn/20190505105302405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)

![{{g}_{y}}=\frac{\partial f}{\partial y}=(\text{P3+2P6+P9)-}(\text{P1+2P4+P7)}](https://private.codecogs.com/gif.latex?%7B%7Bg%7D_%7By%7D%7D%3D%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20y%7D%3D%28%5Ctext%7BP3&plus;2P6&plus;P9%29-%7D%28%5Ctext%7BP1&plus;2P4&plus;P7%29%7D)





opencv代码如下：

```python
# -*- coding: utf-8 -*-
import cv2
import numpy as np
import matplotlib.pyplot as plt
 
# 读取图像
img = cv2.imread('zxp.jpg')
img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
 
# 灰度化处理图像
grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
 
# Sobel算子
x = cv2.Sobel(grayImage, cv2.CV_16S, 1, 0)  # 对x求一阶导
y = cv2.Sobel(grayImage, cv2.CV_16S, 0, 1)  # 对y求一阶导
absX = cv2.convertScaleAbs(x)
absY = cv2.convertScaleAbs(y)
Sobel = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)
 
# 用来正常显示中文标签
plt.rcParams['font.sans-serif'] = ['SimHei']
 
# # 显示图形
# titles = [u'原始图像', u'Sobel算子']
# images = [lenna_img, Sobel]
# for i in xrange(2):
#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')
#     plt.title(titles[i])
#     plt.xticks([]), plt.yticks([])
# plt.show()
 
# 显示图形
plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭
plt.subplot(122),plt.imshow(Sobel, cmap=plt.cm.gray ),plt.title('Sobel算子'), plt.axis('off')
plt.show()
```



运行结果如下:

![img](https://img-blog.csdnimg.cn/20190505150839101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)









# Laplacian 算子

**拉普拉斯(Laplacian) 算子**是n维欧几里德空间中的一个**二阶微分算子**，常用于图像增强领域和边缘提取。它通过灰度差分计算邻域内的像素。

其中，Laplacian算子**四邻域**模板如下所示：

​                                       ![\text{H}=\left[ \begin{matrix} 0 & -1 & 0 \\ -1 & 4 & -1 \\ 0 & -1 & 0 \\ \end{matrix} \right]](https://private.codecogs.com/gif.latex?%5Ctext%7BH%7D%3D%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%200%20%26%20-1%20%26%200%20%5C%5C%20-1%20%26%204%20%26%20-1%20%5C%5C%200%20%26%20-1%20%26%200%20%5C%5C%20%5Cend%7Bmatrix%7D%20%5Cright%5D)

Laplacian算子的**八邻域**模板如下所示：

​                                       ![\text{H}=\left[ \begin{matrix} -1 & -1 & -1 \\ -1 & 8 & -1 \\ -1 & -1 & -1 \\ \end{matrix} \right]](https://private.codecogs.com/gif.latex?%5Ctext%7BH%7D%3D%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%20-1%20%26%20-1%20%26%20-1%20%5C%5C%20-1%20%26%208%20%26%20-1%20%5C%5C%20-1%20%26%20-1%20%26%20-1%20%5C%5C%20%5Cend%7Bmatrix%7D%20%5Cright%5D)



通过Laplacian算子的模板可以发现：

1）当邻域内像素灰度相同时，模板的卷积运算结果为0；

2）当中心像素灰度高于邻域内其他像素的平均灰度时，模板的卷积运算结果为正数；

3）当中心像素的灰度低于邻域内其他像素的平均灰度时，模板的卷积为负数。对卷积运算的结果用适当的衰弱因子处理并加在原中心像素上，就可以实现图像的锐化处理。



opencv代码如下：

```
# -*- coding: utf-8 -*-
import cv2
import numpy as np
import matplotlib.pyplot as plt
 
# 读取图像
img = cv2.imread('zxp.jpg')
img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
 
# 灰度化处理图像
grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
 
# 拉普拉斯算法
dst = cv2.Laplacian(grayImage, cv2.CV_16S, ksize=3)
Laplacian = cv2.convertScaleAbs(dst)
 
# 用来正常显示中文标签
plt.rcParams['font.sans-serif'] = ['SimHei']
 
# # 显示图形
# titles = [u'原始图像', u'Laplacian算子']
# images = [lenna_img, Laplacian]
# for i in xrange(2):
#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')
#     plt.title(titles[i])
#     plt.xticks([]), plt.yticks([])
# plt.show()
 
 
# 显示图形
plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭
plt.subplot(122),plt.imshow(Laplacian, cmap=plt.cm.gray ),plt.title('Laplacian算子'), plt.axis('off')
plt.show()
```



运行结果如下：

![img](https://img-blog.csdnimg.cn/20190505151151845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phaXNodWl5aWZhbmd4eW0=,size_16,color_FFFFFF,t_70)





## Canny算子

Canny边缘检测算子是一种多级检测算法。1986年由John F. Canny提出，同时提出了边缘检测的三大准则：

- 低错误率的边缘检测：检测算法应该精确地找到图像中的尽可能多的边缘，尽可能的减少漏检和误检。
- 最优定位：检测的边缘点应该精确地定位于边缘的中心。
- 图像中的任意边缘应该只被标记一次，同时图像噪声不应产生伪边缘。



Canny边缘检测算法的实现较为复杂,主要分为以下步骤：

- 高斯模糊

- 计算梯度幅值和方向

- 非极大值 抑制

- 滞后阈值

  

```python
"""
cv2.Canny(image,            # 输入原图（必须为单通道图）
          threshold1, 
          threshold2,       # 较大的阈值2用于检测图像中明显的边缘
          [, edges[, 
          apertureSize[,    # apertureSize：Sobel算子的大小
          L2gradient ]]])   # 参数(布尔值)：
                              true： 使用更精确的L2范数进行计算（即两个方向的倒数的平方和再开放），
                              false：使用L1范数（直接将两个方向导数的绝对值相加）。
"""

import cv2
import numpy as np  
 
original_img = cv2.imread("qingwen.png", 0)

# canny(): 边缘检测
img1 = cv2.GaussianBlur(original_img,(3,3),0)
canny = cv2.Canny(img1, 50, 150)

# 形态学：边缘检测
_,Thr_img = cv2.threshold(original_img,210,255,cv2.THRESH_BINARY)#设定红色通道阈值210（阈值影响梯度运算效果）
kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))         #定义矩形结构元素
gradient = cv2.morphologyEx(Thr_img, cv2.MORPH_GRADIENT, kernel) #梯度

cv2.imshow("original_img", original_img) 
cv2.imshow("gradient", gradient) 
cv2.imshow('Canny', canny)

cv2.waitKey(0)
cv2.destroyAllWindows()

```



运行结果如下：
![](https://ganhan999.github.io//post-images/1604651229973.jpg)







## LOG 算子

OG （ Laplacian of Gaussian ） 边缘检测算子是 David Courtnay Marr 和 Ellen Hildreth 在 1980 年共同提出的，也称为 Marr & Hildreth 算子，它根据图像的信噪比来求检测边缘的最优滤波器。该算法首先对图像做高斯滤波，然后再求其拉普拉斯（ Laplacian ）二阶导数，根据二阶导数的过零点来检测图像的边界，即通过检测滤波结果的零交叉（ Zero crossings ）来获得图像或物体的边缘。

LOG 算子实际上是把 Gauss 滤波和 Laplacian 滤波结合了起来，先平滑掉噪声，再进行边缘检测。

LOG 算子与视觉生理中的数学模型相似，因此在图像处理领域中得到了广泛的应用。

它具有抗干扰能力强，边界定位精度高，边缘连续性好，能有效提取对比度弱的边界等特点。



常见的 LOG 算子是5 x 5的模板

![](https://ganhan999.github.io//post-images/1604651236093.png)



LOG 算子到中心的距离与位置加权系数的关系曲线像墨西哥草帽的剖面，所以 LOG 算子也叫墨西哥草帽滤波器。

![img](https://cdn.geekdigging.com/opencv/13/log_caomao.webp)



opencv代码如下：

```python
import cv2 as cv
import matplotlib.pyplot as plt

# 读取图像
img = cv.imread("maliao.jpg")
rgb_img = cv.cvtColor(img, cv.COLOR_BGR2RGB)

gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)

# 先通过高斯滤波降噪
gaussian = cv.GaussianBlur(gray_img, (3, 3), 0)

# 再通过拉普拉斯算子做边缘检测
dst = cv.Laplacian(gaussian, cv.CV_16S, ksize=3)
LOG = cv.convertScaleAbs(dst)

# 用来正常显示中文标签
plt.rcParams['font.sans-serif'] = ['SimHei']

# 显示图形
titles = ['原始图像', 'LOG 算子']
images = [rgb_img, LOG]

for i in range(2):
    plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')
    plt.title(titles[i])
    plt.xticks([]), plt.yticks([])
plt.show()
```



运行结果如下:

![img](https://cdn.geekdigging.com/opencv/13/log_result.png)





# DOG 算子

DoG算子是高斯函数的差分，具体到图像中，就是将图像在不同参数下的高斯滤波结果相减，得到差分图。DoG算子的表达式如下：

![](https://ganhan999.github.io//post-images/1604651116794.png)

其中 k−1是个常数，不影响极值点的检测，LoG算子和DoG算子的函数波形对比如下图所示，由于高斯差分的计算更加简单，因此可用DoG算子近似替代LoG算子。

<img src="https://i.loli.net/2017/12/18/5a3741bdd1528.jpg" alt="LoG-DoG.jpg" style="zoom:200%;" />









